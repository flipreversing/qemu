diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index f88a52393f..a1ff6ada88 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -2799,6 +2799,8 @@ int kvm_update_guest_debug(CPUState *cpu, unsigned long reinject_trap)
 
     data.dbg.control = reinject_trap;
 
+    // TODO: Should we avoid setting KVM_GUESTDBG_SINGLESTEP here?
+    //       Or maybe make sure it's unset when single stepping is done?
     if (cpu->singlestep_enabled) {
         data.dbg.control |= KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_SINGLESTEP;
     }
diff --git a/include/qemu/bitops.h b/include/qemu/bitops.h
index 3acbf3384c..b0d3f030df 100644
--- a/include/qemu/bitops.h
+++ b/include/qemu/bitops.h
@@ -17,7 +17,7 @@
 #include "atomic.h"
 
 #define BITS_PER_BYTE           CHAR_BIT
-#define BITS_PER_LONG           (sizeof (unsigned long) * BITS_PER_BYTE)
+#define BITS_PER_LONG           (__SIZEOF_LONG__ * BITS_PER_BYTE)
 
 #define BIT(nr)                 (1UL << (nr))
 #define BIT_ULL(nr)             (1ULL << (nr))
diff --git a/qemu.patch b/qemu.patch
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 50008431c3..afea127cd2 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -7432,10 +7432,10 @@ static void x86_cpu_common_class_init(ObjectClass *oc, void *data)
     cc->gdb_arch_name = x86_gdb_arch_name;
 #ifdef TARGET_X86_64
     cc->gdb_core_xml_file = "i386-64bit.xml";
-    cc->gdb_num_core_regs = 66;
+    cc->gdb_num_core_regs = 66 + 9;
 #else
     cc->gdb_core_xml_file = "i386-32bit.xml";
-    cc->gdb_num_core_regs = 50;
+    cc->gdb_num_core_regs = 50 + 9;
 #endif
     cc->disas_set_info = x86_disas_set_info;
 
diff --git a/target/i386/gdbstub.c b/target/i386/gdbstub.c
index 41e265fc67..c3e70eeb83 100644
--- a/target/i386/gdbstub.c
+++ b/target/i386/gdbstub.c
@@ -53,8 +53,11 @@ static const int gpr_map32[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };
  * fpu regs ----------> 8 or 16
  */
 #define IDX_NB_MXCSR    1
+#define IDX_NB_DR       6
+#define IDX_NB_HFLAGS   1
+#define IDX_NB_IDT      2
 /*
- *          total ----> 8+1+1+9+6+16+8+1=50 or 16+1+1+9+6+16+16+1=66
+ *          total ----> 8+1+1+9+6+16+8+1+6+1+2=59 or 16+1+1+9+6+16+16+1+6+1+2=75
  */
 
 #define IDX_IP_REG      CPU_NB_REGS
@@ -64,6 +67,9 @@ static const int gpr_map32[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };
 #define IDX_FP_REGS     (IDX_CTL_REGS + IDX_NB_CTL)
 #define IDX_XMM_REGS    (IDX_FP_REGS + IDX_NB_FP)
 #define IDX_MXCSR_REG   (IDX_XMM_REGS + CPU_NB_REGS)
+#define IDX_DR_REGS     (IDX_MXCSR_REG + IDX_NB_MXCSR)
+#define IDX_HFLAGS_REG  (IDX_DR_REGS + IDX_NB_DR)
+#define IDX_IDT_REGS    (IDX_HFLAGS_REG + IDX_NB_HFLAGS)
 
 #define IDX_CTL_CR0_REG     (IDX_CTL_REGS + 0)
 #define IDX_CTL_CR2_REG     (IDX_CTL_REGS + 1)
@@ -227,6 +233,27 @@ int x86_cpu_gdb_read_register(CPUState *cs, GByteArray *mem_buf, int n)
                 return gdb_get_reg64(mem_buf, env->efer);
             }
             return gdb_get_reg32(mem_buf, env->efer);
+
+        case IDX_DR_REGS:
+            return gdb_get_reg64(mem_buf, env->dr[0]);
+        case IDX_DR_REGS + 1:
+            return gdb_get_reg64(mem_buf, env->dr[1]);
+        case IDX_DR_REGS + 2:
+            return gdb_get_reg64(mem_buf, env->dr[2]);
+        case IDX_DR_REGS + 3:
+            return gdb_get_reg64(mem_buf, env->dr[3]);
+        case IDX_DR_REGS + 4:
+            return gdb_get_reg64(mem_buf, env->dr[6]);
+        case IDX_DR_REGS + 5:
+            return gdb_get_reg64(mem_buf, env->dr[7]);
+
+        case IDX_HFLAGS_REG:
+            return gdb_get_reg32(mem_buf, env->hflags);
+
+        case IDX_IDT_REGS:
+            return gdb_get_reg64(mem_buf, env->idt.base);
+        case IDX_IDT_REGS + 1:
+            return gdb_get_reg32(mem_buf, env->idt.limit);
         }
     }
     return 0;
@@ -433,6 +460,24 @@ int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)
             cpu_load_efer(env, ldl_p(mem_buf));
             return 4;
 
+        case IDX_DR_REGS:
+            env->dr[0] = ldq_p(mem_buf);
+            return 8;
+        case IDX_DR_REGS + 1:
+            env->dr[1] = ldq_p(mem_buf);
+            return 8;
+        case IDX_DR_REGS + 2:
+            env->dr[2] = ldq_p(mem_buf);
+            return 8;
+        case IDX_DR_REGS + 3:
+            env->dr[3] = ldq_p(mem_buf);
+            return 8;
+        case IDX_DR_REGS + 4:
+            env->dr[6] = ldq_p(mem_buf);
+            return 8;
+        case IDX_DR_REGS + 5:
+            env->dr[7] = ldq_p(mem_buf);
+            return 8;
         }
     }
     /* Unrecognised register.  */
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index c8d61daf68..1483cad4ee 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -4339,88 +4339,88 @@ static int kvm_handle_tpr_access(X86CPU *cpu)
 
 int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)
 {
-    static const uint8_t int3 = 0xcc;
+    // static const uint8_t int3 = 0xcc;
 
-    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn, 1, 0) ||
-        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&int3, 1, 1)) {
-        return -EINVAL;
-    }
+    // if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn, 1, 0) ||
+    //     cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&int3, 1, 1)) {
+    //     return -EINVAL;
+    // }
     return 0;
 }
 
 int kvm_arch_remove_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)
 {
-    uint8_t int3;
-
-    if (cpu_memory_rw_debug(cs, bp->pc, &int3, 1, 0)) {
-        return -EINVAL;
-    }
-    if (int3 != 0xcc) {
-        return 0;
-    }
-    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn, 1, 1)) {
-        return -EINVAL;
-    }
+    // uint8_t int3;
+
+    // if (cpu_memory_rw_debug(cs, bp->pc, &int3, 1, 0)) {
+    //     return -EINVAL;
+    // }
+    // if (int3 != 0xcc) {
+    //     return 0;
+    // }
+    // if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn, 1, 1)) {
+    //     return -EINVAL;
+    // }
     return 0;
 }
 
-static struct {
-    target_ulong addr;
-    int len;
-    int type;
-} hw_breakpoint[4];
+// static struct {
+//     target_ulong addr;
+//     int len;
+//     int type;
+// } hw_breakpoint[4];
 
 static int nb_hw_breakpoint;
 
-static int find_hw_breakpoint(target_ulong addr, int len, int type)
-{
-    int n;
+// static int find_hw_breakpoint(target_ulong addr, int len, int type)
+// {
+//     int n;
 
-    for (n = 0; n < nb_hw_breakpoint; n++) {
-        if (hw_breakpoint[n].addr == addr && hw_breakpoint[n].type == type &&
-            (hw_breakpoint[n].len == len || len == -1)) {
-            return n;
-        }
-    }
-    return -1;
-}
+//     for (n = 0; n < nb_hw_breakpoint; n++) {
+//         if (hw_breakpoint[n].addr == addr && hw_breakpoint[n].type == type &&
+//             (hw_breakpoint[n].len == len || len == -1)) {
+//             return n;
+//         }
+//     }
+//     return -1;
+// }
 
 int kvm_arch_insert_hw_breakpoint(target_ulong addr,
                                   target_ulong len, int type)
 {
-    switch (type) {
-    case GDB_BREAKPOINT_HW:
-        len = 1;
-        break;
-    case GDB_WATCHPOINT_WRITE:
-    case GDB_WATCHPOINT_ACCESS:
-        switch (len) {
-        case 1:
-            break;
-        case 2:
-        case 4:
-        case 8:
-            if (addr & (len - 1)) {
-                return -EINVAL;
-            }
-            break;
-        default:
-            return -EINVAL;
-        }
-        break;
-    default:
-        return -ENOSYS;
-    }
-
-    if (nb_hw_breakpoint == 4) {
-        return -ENOBUFS;
-    }
-    if (find_hw_breakpoint(addr, len, type) >= 0) {
-        return -EEXIST;
-    }
-    hw_breakpoint[nb_hw_breakpoint].addr = addr;
-    hw_breakpoint[nb_hw_breakpoint].len = len;
-    hw_breakpoint[nb_hw_breakpoint].type = type;
+    // switch (type) {
+    // case GDB_BREAKPOINT_HW:
+    //     len = 1;
+    //     break;
+    // case GDB_WATCHPOINT_WRITE:
+    // case GDB_WATCHPOINT_ACCESS:
+    //     switch (len) {
+    //     case 1:
+    //         break;
+    //     case 2:
+    //     case 4:
+    //     case 8:
+    //         if (addr & (len - 1)) {
+    //             return -EINVAL;
+    //         }
+    //         break;
+    //     default:
+    //         return -EINVAL;
+    //     }
+    //     break;
+    // default:
+    //     return -ENOSYS;
+    // }
+
+    // if (nb_hw_breakpoint == 4) {
+    //     return -ENOBUFS;
+    // }
+    // if (find_hw_breakpoint(addr, len, type) >= 0) {
+    //     return -EEXIST;
+    // }
+    // hw_breakpoint[nb_hw_breakpoint].addr = addr;
+    // hw_breakpoint[nb_hw_breakpoint].len = len;
+    // hw_breakpoint[nb_hw_breakpoint].type = type;
     nb_hw_breakpoint++;
 
     return 0;
@@ -4429,15 +4429,7 @@ int kvm_arch_insert_hw_breakpoint(target_ulong addr,
 int kvm_arch_remove_hw_breakpoint(target_ulong addr,
                                   target_ulong len, int type)
 {
-    int n;
-
-    n = find_hw_breakpoint(addr, (type == GDB_BREAKPOINT_HW) ? 1 : len, type);
-    if (n < 0) {
-        return -ENOENT;
-    }
     nb_hw_breakpoint--;
-    hw_breakpoint[n] = hw_breakpoint[nb_hw_breakpoint];
-
     return 0;
 }
 
@@ -4471,13 +4463,15 @@ static int kvm_handle_debug(X86CPU *cpu,
                     case 0x1:
                         ret = EXCP_DEBUG;
                         cs->watchpoint_hit = &hw_watchpoint;
-                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;
+                        // hw_watchpoint.vaddr = hw_breakpoint[n].addr;
+                        hw_watchpoint.vaddr = env->dr[n];
                         hw_watchpoint.flags = BP_MEM_WRITE;
                         break;
                     case 0x3:
                         ret = EXCP_DEBUG;
                         cs->watchpoint_hit = &hw_watchpoint;
-                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;
+                        // hw_watchpoint.vaddr = hw_breakpoint[n].addr;
+                        hw_watchpoint.vaddr = env->dr[n];
                         hw_watchpoint.flags = BP_MEM_ACCESS;
                         break;
                     }
@@ -4501,31 +4495,24 @@ static int kvm_handle_debug(X86CPU *cpu,
     return ret;
 }
 
-void kvm_arch_update_guest_debug(CPUState *cpu, struct kvm_guest_debug *dbg)
+void kvm_arch_update_guest_debug(CPUState *cs, struct kvm_guest_debug *dbg)
 {
-    const uint8_t type_code[] = {
-        [GDB_BREAKPOINT_HW] = 0x0,
-        [GDB_WATCHPOINT_WRITE] = 0x1,
-        [GDB_WATCHPOINT_ACCESS] = 0x3
-    };
-    const uint8_t len_code[] = {
-        [1] = 0x0, [2] = 0x1, [4] = 0x3, [8] = 0x2
-    };
-    int n;
+    X86CPU *cpu = X86_CPU(cs);
+    CPUX86State *env = &cpu->env;
 
-    if (kvm_sw_breakpoints_active(cpu)) {
+    if (kvm_sw_breakpoints_active(cs)) {
         dbg->control |= KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP;
     }
+
     if (nb_hw_breakpoint > 0) {
         dbg->control |= KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_HW_BP;
-        dbg->arch.debugreg[7] = 0x0600;
-        for (n = 0; n < nb_hw_breakpoint; n++) {
-            dbg->arch.debugreg[n] = hw_breakpoint[n].addr;
-            dbg->arch.debugreg[7] |= (2 << (n * 2)) |
-                (type_code[hw_breakpoint[n].type] << (16 + n*4)) |
-                ((uint32_t)len_code[hw_breakpoint[n].len] << (18 + n*4));
-        }
     }
+
+    dbg->arch.debugreg[0] = env->dr[0];
+    dbg->arch.debugreg[1] = env->dr[1];
+    dbg->arch.debugreg[2] = env->dr[2];
+    dbg->arch.debugreg[3] = env->dr[3];
+    dbg->arch.debugreg[7] = env->dr[7];
 }
 
 static bool host_supports_vmx(void)
diff --git a/ui/keycodemapdb b/ui/keycodemapdb
index 6119e6e19a..320f92c36a 160000
--- a/ui/keycodemapdb
+++ b/ui/keycodemapdb
@@ -1 +1 @@
-Subproject commit 6119e6e19a050df847418de7babe5166779955e4
+Subproject commit 320f92c36a80bfafc5d57834592a7be5fd79f104
